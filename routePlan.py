import osmnx as ox
import networkx as nx
import folium
from folium.features import DivIcon

import routeFinding

# Should we plot & save the input map to check that it is the right map?
SANITY_CHECK = True

# load graph from GML
# For the last deliverable, change the file to 'graph_student.gml' generated by
# your chosen destination in load_map.py
graph = ox.io.load_graphml('graph_ubc.gml')

if SANITY_CHECK:
    # ...................................
    # Visualize map for sanity check
    fig, ax = ox.plot_graph(graph)
    fig.savefig('ubc_map.png')

    # ...................................
    # Visualize map with elevation for sanity check
    nc = ox.plot.get_node_colors_by_attr(graph, 'elevation', cmap='plasma')
    fig, ax = ox.plot_graph(graph, node_color=nc, node_size=5, edge_color='#333333', bgcolor='k')
    fig.savefig('ubc_elevation.png')


# =======================================================
# Main driving code starts here
#
# Choose a starting location. 
# Example location: the reconciliation pole on Main Mall.
#lat, lon = 49.2600154, -123.2510869
# Example location: Wreck Beach.
lat, lon = 49.255, -123.255

# Graph algorithm requires that start location is a graph node
# so find the one nearest our specified lat-long.
start = ox.nearest_nodes(graph, lon, lat)
startlat, startlon = graph.nodes[start]['y'], graph.nodes[start]['x']

goal_dist = 5000  # meters, must go at least this far

route, time = routeFinding.find_route(start, goal_dist, graph) # calls the main DFS function

# variable 'route' is a DiGraph, but we want a sequence of vertices along the solution path.
# take a look at these variables to see what's going on.
sorted_route = sorted(route.edges(), key=lambda x: route.edges[x[0], x[1]]['time'])
# TODO: Use a list comprehension to assemble the list of vertices in order.
route_vertices = []

# find coordinates of stopping point: last node on the route
endlat, endlon = graph.nodes[route_vertices[-1]]['x'], graph.nodes[route_vertices[-1]]['y']

# add an accumulator that sums the total elevation gain over the course of the
# workout. If an edge (u,v) in the graph corresponds to a downhill segment (difference
# in elevations from u to v is negative), then it is ignored.
eg = routeFinding.total_elevation_gain(graph,route_vertices) # sums the elevation gain over the route


# =================================
# VISUALIZATION!!
# Complete the visualization by adding a finishing circle at the end!

# In order to get the rainbow colors in our plot, we have to plot one edge of the
# route at a time, calculating the color of each edge.
route_gdf = ox.routing.route_to_gdf(graph, route_vertices)

kwargs = { 'style_kwds' : dict(weight=5) }
# If we just use route_gdf.iterrows(), we get Pandas rows, not GeoDataFrame rows
for i, index in enumerate(route_gdf.index):
    row_gdf = route_gdf.loc[[index]]
    if i == 0:
        # Need to create the map for the first edge.
        m = row_gdf.explore(color=routeFinding.shade_given_time(i, time), **kwargs)
    else:
        # Add to the existing map.
        m = row_gdf.explore(m=m, color=routeFinding.shade_given_time(i, time), **kwargs)
        
# Place the elevation gain on the map at the end point of the workout.
folium.map.Marker(
    [endlat, endlon],
    icon=DivIcon(
        icon_size=(250,36),
        icon_anchor=(0,0),
        html=f'<div style="font-size: 20pt">Elevation Gain: {eg}m</div>',
    )
).add_to(m)

# Add green start circle.
folium.CircleMarker((startlat,startlon),
                    color='green',radius=10,fill=True).add_to(m)
# Add blue end circle
# TODO: Add your code here.

filepath = "route_graph_workout.html"
m.save(filepath)
