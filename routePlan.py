import osmnx as ox
import networkx as nx
from collections import deque
import colorsys
from folium.features import DivIcon
import folium
import random
import routeFinding

# load graph from GML
# For the last deliverable, change the file to 'graph_student.gml' generated by
# your chosen destination in load_map.py
graph = ox.io.load_graphml('graph_ubc.gml')

# ...................................
# Visualize map for sanity check
fig, ax = ox.plot_graph(graph)
fig.savefig('ubc_map.png')

# ...................................
# Visualize map with elevation for sanity check
nc = ox.plot.get_node_colors_by_attr(graph, 'elevation', cmap='plasma')
fig, ax = ox.plot_graph(graph, node_color=nc, node_size=5, edge_color='#333333', bgcolor='k')
fig.savefig('ubc_elevation.png')


# =======================================================
# Main driving code starts here
#
# Choose a starting location. 
# For the last deliverable, choose a starting coordinate that corresponds to your map
# # location of the reconciliation pole
#lat, lon = 49.2600154, -123.2510869
# Wreck Beach
lat, lon = 49.255, -123.255

start = ox.nearest_nodes(graph, lon, lat) # start is a node number -- not very useful to us
startlat, startlon = graph.nodes[start]['y'], graph.nodes[start]['x']


goal_dist = 5000  # meters, must go at least this far

route, time = routeFinding.find_route(start, goal_dist, graph) # calls the main dfs function

# variable 'route' is a DiGraph, but we want a sequence of vertices along the solution path.
# take a look at these variables to see what's going on.
sorted_lst = sorted(route.edges(), key=lambda x: route.edges[x[0], x[1]]['time'])
# TODO: Use a list comprehension to assemble the list of vertices in order.
routevertices = []

# find coordinates of stopping point: last node on the route
endlat, endlon = graph.nodes[routevertices[-1]]['x'], graph.nodes[routevertices[-1]]['y']

# add an accumulator that sums the total elevation gain over the course of the
# workout. If an edge (u,v) in the graph corresponds to a downhill segment (difference
# in elevations from u to v is negative), then it is ignored.
eg = routeFinding.total_elevation_gain(graph,routevertices) # sums the elevation gain over the route




# =================================
# VISUALIZATION!!
# Complete the visualization by adding a finishing circle at the end!
#

# Plotting is strange. In order to get the rainbow colors, we have to plot one edge of the
# route at a time, calculating the color of each.

# Initialize the map plot
kwargs = {'opacity': 0}
m = ox.plot_graph_folium(graph, tiles='openstreetmap', **kwargs)


# Add the edges in the graph one at a time so you can specify a
# different color for each edge. route_map=m plots on map m
for k,x in enumerate(sorted_lst[1:]):
    kwargs = {'opacity': 1.0}
    ox.plot_route_folium(graph, x, route_map=m, weight=5, color=routeFinding.shade_given_time(k, time), **kwargs)

# need to get the right zoom level for the whole route. Lots of ways of doing this more dynamically. We're just
# going to take a 1200m radius from the start location. bbox stands for bounding box
bbox = ox.utils_geo.bbox_from_point((startlat, startlon), dist=1200)
swne = [(min(bbox[0:2]),min(bbox[2:4])),(max(bbox[0:2]),max(bbox[2:4]))]
m.fit_bounds(swne)

# Place the elevation gain on the map at the end point of the workout.
folium.map.Marker(
    [endlat, endlon],
    icon=DivIcon(
        icon_size=(250,36),
        icon_anchor=(0,0),
        html=f'<div style="font-size: 20pt">Elevation Gain: {eg}m</div>',
    )
).add_to(m)

# Add green start circle
folium.CircleMarker((startlat,startlon),
                    color='green',radius=5,fill=True).add_to(m)
# Add red end circle
# TODO Your code here

filepath = "route_graph_workout.html"
m.save(filepath)
